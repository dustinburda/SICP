#lang scheme

; Exercise 1.1
10 ;10

(+ 5 3 4) ;12

(- 9 1) ;8

(/ 6 2) ;3

(+ (* 2 4) (- 4 6)) ;6

(define a 3)

(define b (+ a 1)) 

(+ a b (* a b)) ;19

(= a b) ; false

(if (and (> b a) (< b (* a b)))
b
a) ;4

(cond ((= a 4) 6)
((= b 4) (+ 6 7 a))
(else 25)) ; 16

(+ 2 (if (> b a) b a)) ;6

(* (cond ((> a b) a)
((< a b) b)
(else -1))
(+ a 1)) ;16



; Exercise 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))

   
; Exercise 1.3
(define (sum-square-min x y z)
  (cond ( (and (not (< z y)) (not (< z x)) ) (+ (* x x) (* y y)))
        ( (and (not (< x y)) (not (< x z)) ) (+ (* y y) (* z z)))
        ( (and (not (< y z)) (not (< y z)) ) (+ (* z z) (* x x))))
)


; Exercise 1.4
; The procedure will select a different operator depending on the sign of b.


; Exercise 1.5
;(define (p) (p))
;(define (test x y)
;  (if (= x 0) 0 y)
;  )
;(test 0 (p))

; Substitution Model/ Applicative Order 
; Evaluate each the arguments and then apply
; 
; (test 0 (p))
; Eval test -> replace with body
; Eval 0 -> 0
; Eval -> (p) ----> Would get stuck evaluating (p)


; Normal-order Evaluation
; Fully expand and then reduce
;
; Will not evaluate parameters until they are needed
;
; (test 0 (p))
; Reduce ---> (if (= 0 0) 0 (p))
; Evaluate first parameter


; Exercise 1.6

#| (define (new_if predicate then-clause else-clause)
     (cond (predicate then-clause)
           (else else-clause)
     )
   )
   
   ; Here, new_if will evaluate ALL of its arguments, in particular, it will rerun cuberoot_iter_alt
   ; before evaluating new_if 
   (define (cuberoot_iter_alt guess x)
     (new_if (good-enough? guess x)
         guess
     (cuberoot_iter_alt (update guess x) x))
   )
   
   (define (cube_root_alt x) (cuberoot_iter_alt 1.0 x))
   
(define cube_root 27) |#



; Exercise 1.7
; TODO


;1.8 Helper method

(define (abs x)
  (cond
    ((< x 0) (- x))
    (else x)
    )
)


; Exercise 1.8

(define (cuberoot x) (cuberoot-iter 1.0 x))
   
(define (cuberoot-iter guess x)
  (if (good-enough? guess x)
      guess
  (cuberoot-iter (update guess x) x))
)

(define (good-enough? guess x)
  (< (abs (- (cube guess) x)) 5.0)
)

(define (cube x)
  (* x x x)
)

(define (update guess x)
  (/
   (+ (/ x (* guess guess))
      (* 2 guess))
   3)
)

(cuberoot 27)


; Exercise 1.9
#|
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))


Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5).
Are these processes iterative or recursive? 


(+ 4 5)

(if (= 4 0) 5 (inc (+ (dec 4) 5))))
(if (= 4 0) 5 (inc (+ 3 5))))

(inc (+ 3 5))
(inc (inc (+ 2 5))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9




9
This process is recursive




(+ 4 5)
(if (= 4 0) 5 (+ (dec 4) (inc 5))))
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

This process is iterative
|#



; Exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

#|

(define (f n) (A 0 n)

(A 0 n)
(* 2 n)
2n




(define (g n) (A 1 n))

(A 1 n)
(A 0 (A 1 (- n 1)))
2 * (A 1 ( - n 1)))
2 * 2 * (A 1 (- (- n 1) 1)))
...
2 * 2 ... * 2 * (A 1 1))
2 * 2 ... * 2 * 2 

2**n



(A 2 n)
(A 1 (A 2 (- n 1))
2 ** (A 2 (- n 1))
2 ** 2** (A 2 (- (- n 1))
...
2 ** 2 ** 2 ** ... (A 2 1)
2 ** 2 ** 2 ** ... 2

2

|#


; Exercise 1.11


; Recursive

(define (f_recursive n)
  (cond ((< n 3) n)
        (else (+ (f_recursive (- n 1)) (* 2 (f_recursive (- n 2))) (* 3 (f_recursive (- n 3))) ))
        ))

; Linear Recursive

(define (f_linear_n n)
  (f_linear_iter_n 2 1 0 n))

(define (f_linear_iter_n a b c count)
  (cond ((= count 0) c)
        (else (f_linear_iter_n (+ a (* 2 b) (* 3 c)) a b (- count 1)))))

100000000000

(f_recursive 0)
(f_recursive 1)
(f_recursive 2)
(f_recursive 3)
(f_recursive 4)
(f_recursive 5)
(f_recursive 10)
(f_recursive 11)
(f_recursive 12)
(f_recursive 13)
(f_recursive 14)
(f_recursive 15)
(f_recursive 16)
(f_recursive 17)


(f_linear_n 0)
(f_linear_n 1)
(f_linear_n 2)
(f_linear_n 3)
(f_linear_n 4)
(f_linear_n 5)
(f_linear_n 10)
(f_linear_n 11)
(f_linear_n 12)
(f_linear_n 13)
(f_linear_n 14)
(f_linear_n 15)
(f_linear_n 16)
(f_linear_n 17)



; Excercise 1.14

#|
Draw the tree illustrating the process generated by count-change procedure on Section 1.2.2 in making
change for 11 cents. What are the orders of growth of the space and number of steps used by this process
as the amount to be changed increases?

11,5
11,4  -39,5
11,3 -14,5 0
11,2 1,3 0 0
11,1 6,2 1,2 -9,3 0 0
11,0 10,1 6,1 1,2 1,1 -4,1 0 0 0
0 10,0 9,1 6,0 5,1 1,1 -4,1 1 0 0 0
0 0 1 0 1 1 0 1 0 0 0

4


1,1 ... ,1  (11 pennies)
1,1,1,1,1,1, 5 (6 pennies, 1 nickel)
5,5,1 (2 nickels, 1 penny)
10, 1 (1 dime, 1 penny)

Space increases linearly with n (the deepest root will always be of length n, consisting of only pennies)
Number of steps grows with n**5
|#



; Exercise 1.15

#|
a) How many times is procedure p applied when (sine 12.15) is evaluated?


(12.15) / (3**n) < 0.1

(3**n) / 12.15 > 10

3**n > 121.5

n > 4

n = 5



b) What is the order of growth in space and number of steps used by the process generated by the sine procedure
when it is evaluated?

Space:  a / 3**n > 0.1
        3**n > 10 * a
        n > log3(10 * a)
       floor(log3(10*a))
       floor (log3(10*a))

      Grows with log3(10*a)

Number of steps: Same as space log3(a)

|#


; Exercise 1.16


#|
Design a procedure that evolves an iterative exponentiation process that uses successive squaring
and uses a logarithmic number of steps 
|#


(define (expt b n)
  (expt_iter b n 1))

(define (even n)
  (= (remainder n 2) 0))

(define (expt_iter b n amount)
  (cond ((= n 0) amount)
        ((even n) (expt_iter (* b b) (/ n 2) amount))
        (else  (expt_iter b (- n 1) (* amount b) ))))


(expt 2 10)










