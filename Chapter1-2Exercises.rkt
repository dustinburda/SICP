#lang scheme
; Exercise 1.9
#|
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))


Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5).
Are these processes iterative or recursive? 


(+ 4 5)

(if (= 4 0) 5 (inc (+ (dec 4) 5))))
(if (= 4 0) 5 (inc (+ 3 5))))

(inc (+ 3 5))
(inc (inc (+ 2 5))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9




9
This process is recursive




(+ 4 5)
(if (= 4 0) 5 (+ (dec 4) (inc 5))))
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

This process is iterative
|#



; Exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

#|

(define (f n) (A 0 n)

(A 0 n)
(* 2 n)
2n




(define (g n) (A 1 n))

(A 1 n)
(A 0 (A 1 (- n 1)))
2 * (A 1 ( - n 1)))
2 * 2 * (A 1 (- (- n 1) 1)))
...
2 * 2 ... * 2 * (A 1 1))
2 * 2 ... * 2 * 2 

2**n



(A 2 n)
(A 1 (A 2 (- n 1))
2 ** (A 2 (- n 1))
2 ** 2** (A 2 (- (- n 1))
...
2 ** 2 ** 2 ** ... (A 2 1)
2 ** 2 ** 2 ** ... 2

2

|#


; Exercise 1.11


; Recursive

(define (f_recursive n)
  (cond ((< n 3) n)
        (else (+ (f_recursive (- n 1)) (* 2 (f_recursive (- n 2))) (* 3 (f_recursive (- n 3))) ))
        ))

; Linear Recursive

(define (f_linear_n n)
  (f_linear_iter_n 2 1 0 n))

(define (f_linear_iter_n a b c count)
  (cond ((= count 0) c)
        (else (f_linear_iter_n (+ a (* 2 b) (* 3 c)) a b (- count 1)))))

100000000000

(f_recursive 0)
(f_recursive 1)
(f_recursive 2)
(f_recursive 3)
(f_recursive 4)
(f_recursive 5)
(f_recursive 10)
(f_recursive 11)
(f_recursive 12)
(f_recursive 13)
(f_recursive 14)
(f_recursive 15)
(f_recursive 16)
(f_recursive 17)


(f_linear_n 0)
(f_linear_n 1)
(f_linear_n 2)
(f_linear_n 3)
(f_linear_n 4)
(f_linear_n 5)
(f_linear_n 10)
(f_linear_n 11)
(f_linear_n 12)
(f_linear_n 13)
(f_linear_n 14)
(f_linear_n 15)
(f_linear_n 16)
(f_linear_n 17)



; Excercise 1.14

#|
Draw the tree illustrating the process generated by count-change procedure on Section 1.2.2 in making
change for 11 cents. What are the orders of growth of the space and number of steps used by this process
as the amount to be changed increases?

11,5
11,4  -39,5
11,3 -14,5 0
11,2 1,3 0 0
11,1 6,2 1,2 -9,3 0 0
11,0 10,1 6,1 1,2 1,1 -4,1 0 0 0
0 10,0 9,1 6,0 5,1 1,1 -4,1 1 0 0 0
0 0 1 0 1 1 0 1 0 0 0

4


1,1 ... ,1  (11 pennies)
1,1,1,1,1,1, 5 (6 pennies, 1 nickel)
5,5,1 (2 nickels, 1 penny)
10, 1 (1 dime, 1 penny)

Space increases linearly with n (the deepest root will always be of length n, consisting of only pennies)
Number of steps grows with n**5
|#



; Exercise 1.15

#|
a) How many times is procedure p applied when (sine 12.15) is evaluated?


(12.15) / (3**n) < 0.1

(3**n) / 12.15 > 10

3**n > 121.5

n > 4

n = 5



b) What is the order of growth in space and number of steps used by the process generated by the sine procedure
when it is evaluated?

Space:  a / 3**n > 0.1
        3**n > 10 * a
        n > log3(10 * a)
       floor(log3(10*a))
       floor (log3(10*a))

      Grows with log3(10*a)

Number of steps: Same as space log3(a)

|#


; Exercise 1.16


#|
Design a procedure that evolves an iterative exponentiation process that uses successive squaring
and uses a logarithmic number of steps 
|#


(define (expt b n)
  (expt_iter b n 1))

(define (even n)
  (= (remainder n 2) 0))

(define (expt_iter b n amount)
  (cond ((= n 0) amount)
        ((even n) (expt_iter (* b b) (/ n 2) amount))
        (else  (expt_iter b (- n 1) (* amount b) ))))


(expt 2 10)





; Exercise 1.17

#|
Design a multiplication procedure analogous to fast-expt that uses a logarithmic number of steps.
|#


(define (mult_recur a b)
  (cond ((= b 0) 0)
        ((= b 1) a)
        ((= (remainder b 2) 0) (mult_recur (+ a a) (/ b 2)))
        (else (+ a (mult_recur a (- b 1))))))

(mult_recur 4 5)


; Exercise 1.18

#|
Design a procedure that generates an interative process for multiplying two integers
in terms of adding, doubling, and halving thar uses a logarthmic number of steps
|#





(define (mult a b)
  (multi_iter a b 0))


(define (multi_iter a b result)
  (cond ((= b 0) result)
        ((= (remainder b 2) 0) (multi_iter (+ a a) (/ b 2) result))
        (else (multi_iter a (- b 1) (+ result a)))))

(mult 4 5)


; Exercidse 1.20


#|
Suppose we interpret the recursive gcd(a,b) procedure in the chapter using normal-order evaluation
and applicative order evaluation. How many remainder operations are actually performed to compute
gcd (206, 40) in each case?




Applicative Order:

gcd (206 40)

gcd (40 (remainder 206 40))

gcd (40 26)

gcd (26 (remainder 40 6))

gcd (26 4)

gcd (4 (remainder 26 4))

gcd (4 2)

gcd(2 (remainder 4 2))

gcd (2 0)


2


4 remainder operations





Normal Order:


NOT DOING THIS
|#



; Exercise 1.21

(define (square x)
  (* x x))


(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (smallest-divisor n)
  (find-divisor n 2))



(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)


; Exercise 1.22
; Exercise 1.23
; Exercise 1.26
; Exercise 1.27